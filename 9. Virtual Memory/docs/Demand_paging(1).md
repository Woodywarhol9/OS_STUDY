# Virtual Memory

- 프로세스의 실행을 할 수 있도록 하는 테크닉
  - 메모리에 완전히 올리지 않아도
  - 프로그램이 물리적 메모리 용량보다 커도

메모리를 굉장히 큰 저장공간으로 추상화한다.
  - logical memory와 physical memory를 분리

굉장히 효율적인 매커니즘
  - 파일, 라이브러리를 공유하거나 프로세스 생성할때 유용

----

- logical한 무한대의 공간을 가지는 가상메모리
- 실제로 physical 메모리가 존재하고 그때 그때 필요할 때 마다 맵핑하여 실행
- 실제 physical 메모리에 로드된 페이지를 제외한 나머지는 backing store(hdd)에 저장하여 메인메모리를 좀 더 효율적으로 사용

----

Virtual Address Space
- logical한 메모리 구조
- logical address는 address 0에서 시작해서 max까지
- contiguous한 메모리 사용
  
  >text : code 사이즈만큼 메모리 차지 (low memory)
  >data : 전역변수 데이터영역
  >heap : 동적할당
  >stack : 함수호출, 지역변수 (high memory)
  
---
### Page Sharing
가상메모리를 사용할 경우 파일과 메모리의 공유가 쉬워진다.
공유되는 페이지가 필요할 때 프로세스 A와 프로세스 B가 공유하는 페이지에 저장해놓으면
접근하는데 유용(Page Sharing)

---

### Executable program

1. secondary storage(hdd, sdd)에 있는 실행파일이 메모리에 로드됨
2. physical memory에 전체 프로그램을 로딩하는 것은 contiguous allocation인데 현실에서는 잘 사용하지 않음
3. *demand paging* 
    - 요청할때만 프로그램을 로드
    - 하지만 요청할 때만 올리게 되면 많은 문제가 생김 
4. virtual memory를 어떻게 관리할 것인가?
   - 실행중에 demand 됐을 때 로딩하는 페이지를 어떻게 관리할 것인가?

---
###

프레임(Frame): 물리 메모리를 사용하는 최소 크기 단위.

페이지(Page): 가상 메모리를 사용하는 최소 크기 단위.

로드할 때 무작위로 위치 및 크기를 설정하여 로드하면 메모리 공간에 빈공간(hole)이 발생하게 된다.  이를 최소화하기 위해 프레임과 페이지를 도입하였으며, 프레임과 페이지의 크기는 보통 같으며, 페이지는 프로세스의 구성요소라고 볼 수 있다. 

---

### Demand paging

운영체제의 스와퍼(Swapper)는 물리 메모리에 동작하고 있는 모든 프로세스를 로드하지 않는다. 게다가 운영체제의 페이저(Pager)는 프로세스의 모든 페이지를 물리메모리에 로드하지 않는다.(물리 메모리를 효율적으로 사용하기 위해서이다.)  그러므로 프로그램의 페이지가 물리 메모리에 부재할 수 있는데, 이것을 **페이지 폴트(Page Fault)**라고 한다. 

 페이지 폴트가 발생하면, 해당 페이지를 가상 메모리에서 찾아야한다. 이 때 운영체제가 페이지 폴트를 해결하는 과정을 Demand Paging이라고 한다. 

어떤 프로세스가 실행중일 때는 페이지가 메모리에 있다고 가정하고 어떤 경우는 seconday 저장장치에 위치

페이지가 메모리에 위치했는지 그 외 저장장치에 있는지 구별을 위해서는 하드웨어의 도움이 필요
- valid-invalid bit 스키마가 사용됨
- valid : page가 메모리에 있어도 legal
- invalid
    1. 메모리 영역을 벗어나서 참조하여 segmentation fault를 일으키는 경우
    2. seconday 저장장치에 위치한 경우
       - dirty bit를 사용해서 1,2 구분 가능
  
---
### Page fault handling

1. CPU는 물리 메모리을 확인하여 페이지가 없으면 trap을 발생하여 운영체제에 알린다.
 
2. 운영체제는 CPU의 동작을 잠시 멈춘다.

3. 운영체제는 페이지 테이블을 확인하여 가상 메모리에 페이지가 존재하는지 확인하고, 없으면 프로세스를 중단한다.

4. 페이지 폴트이면, 현재 물리 메모리에 비어있는 프레임(Free Frame)이 있는지 찾는다.

5. 비어있는 프레임에 해당 페이지를 로드하고, 페이지 테이블을 최신화 한다.

6. 중단되었던 CPU를 다시 시작한다. 



---

### Pure Demand Paing

요청할때만 페이지를 가져옴
- 하드디스크의 프로그램에 페이지가 있을 때 필요할 때만 (page fault가 발생하면) page를 메모리에 로드
- 처음에는 하나의 페이지도 로드될 필요가 없음
  페이지가 필요할 때마다 그 페이지를 page in 시킴
- 필요할 때마다 페이지를 가져와야 하기 때문에 **비효율적**

---

### Locality of Reference

동일한 값 또는 해당 값에 관계된 스토리지 위치가 자주 액세스되는 특성으로, 지역성의 원리(principle of locality)라고도 불립니다. 

참조 지역성의 3가지 기본형 : 시간, 공간, 순차(sequential) 지역성.

- 참조 지역성의 종류 -

1) 공간(spatial) 지역성 : 특성 클러스터의 기억 장소들에 대해 참조가 집중적으로 이루어지는 경향으로, 참조된 메모리 근처의 메모리를 참조합니다.

2) 시간(temporal) 지역성 : 최근 사용되었던 기억 장소들이 집중적으로 액세스되는 경향으로, 참조했던 메모리는 빠른 시간에 다시 참조될 확률이 높습니다.

3) 순차(sequential) 지역성 : 데이터가 순차적으로 액세스되는 경향으로, 프로그램 내의 명령어가 순차적으로 구성되어 있다는 것이 대표적인 경우입니다. 공간 지역성에 편입되어 설명되기도 합니다.


